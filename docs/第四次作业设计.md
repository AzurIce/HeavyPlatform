# 第四次作业设计

## 1. 商品

考察 京东/淘宝 等平台的设计，为了方便会将同一种「商品」的不同选项放在一起，而每个选项都有自己的详情页。

在我们的设计中，引入一个「商品组」的概念来简单地实现这个逻辑：

- 一个「商品」为一个具体的选项，对应着唯一的详情页。
- 「商品组」将多个商品组合在一起，其中任何一个「商品」的页面下的“选项”中会显示其他同「商品组」的「商品」

<s>具体结构如下：</s>

```ts
/* type GoodGroup = {
	id: number,
	goods: number[]
} */
```

算啦，为了后台搓起来简单些，这里直接用类似路径压缩并查集的思想来实现（因为逻辑上来说，我们只在乎哪些商品是一组，而不在乎这个组有什么样的属性），查找同组物品时直接对全部物品 filter 一下得了（反正商品也没那么多，搓个作业而已），不单独做一个 GoodGroup 结构了。

为了保证可以直接通过一次 filter 获取到所有同组物品（同一组所有 parent 相同），每一次“合并操作”应该通过获取所有另组物品并设置 parent 为当前组的 parent。

```ts
type Good = {
    id: number,
    // group_id: number | undefined,
    parent_id: number
    category_id: number,
    name: string,
    price: number,
    imgs: string[],        // 详情页首部的图片
    description: string,   // 对应副标题位置的描述
    specification: string, // 参数，偷懒，直接整个 string 得了
    detail: string         // 详细信息
}
```

```ts
type GoodCategory = {
	id: number,
    name: string,
}
```

---

商品的详细页面为 `/goods/:id`，切换选择时直接跳转另一个商品的 id 的 url 即可。

分类页面为 `/categories/:id`，将所有属于该类别的商品卡片显示出来。

---

1. 主页商品卡片：`/components/GoodCard`

    > 难度简单，工作量少

    显示在主页/搜索结果中的商品卡片

    ```ts
    const GoodCard: Component<{id: number}> = (props) => {
        // ...
    }
    ```

    <img src="./docs/assets/image-20240603165926107.png" alt="image-20240603165926107" style="zoom:50%;" />

2. 分类商品页：`/pages/Main/Categories`

    > 难度中等，工作量少
    >
    > 需要学习一下 https://github.com/solidjs/solid-router?tab=readme-ov-file#dynamic-routes

3. 商品详情页：`/pages/Main/Good`

    > 难度中等，工作量中等
    >
    > 需要学习一下 https://github.com/solidjs/solid-router?tab=readme-ov-file#dynamic-routes

    <img src="./docs/assets/image-20240603165758177.png" alt="image-20240603165758177" style="zoom:50%;" />

## 2. 购物车、订单

简化逻辑，订单被视为若干购物车项的列表。立即下单也即创建一个 CartItem 后用其直接创建 Order。

下单后，CartItem 被移除，并创建对应的 Order。

```ts
type CartItem = {
    id: number,
    good_id: number,
    user_id: number,
    quantity: number,
}
```

```ts
type Order = {
    id: number,
    user_id: number,
    items: CartItem[]
}
```

---

购物车页面路由为 `/cartitems`

订单页面路由为 `/orders`

---

1. 创建订单组件

    > 难度较难，工作量中等

    做成组件而非页面的原因是，组件方便传参，可以实现成一个 Modal（参考 `/components/MenuItem/CreateMenuItemModal.tsx`）。

    ```ts
    const GoodCard: Component<{show: Accessor<boolean>, cartItems: Accessor<CardItem[]>}> = (props) => {
        // ...
    }
    ```
    
    在这个组件里面同时再做一下支付和支付成功（支付成功才会创建订单）
    
    就整体上是一个弹窗来创建订单，点下一步，内容变成支付，再点立即支付，内容变成支付成功，这个时候添加到订单列表里。
    
1. 购物车页面：`/pages/Main/CartItems`

    > 难度简单，工作量中等

1. 订单列表页面：`/pages/Main/Orders`

    > 难度简单，工作量中等

1. 我的页面：`/pages/Main/Me`

    > 难度简单，工作量中等
